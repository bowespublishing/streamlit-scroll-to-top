{"ast":null,"code":"import{Streamlit,StreamlitComponentBase,withStreamlitConnection}from\"streamlit-component-lib\";import React from\"react\";import{PDFDocument}from\"pdf-lib\";import{jsx as _jsx}from\"react/jsx-runtime\";class PDFComponent extends StreamlitComponentBase{constructor(){super(...arguments);this.isProcessing=false;// Guard to prevent double execution\nthis.lastProcessedImageData=null;// Store the last processed image data\nthis.lastProcessedFileName=null;// Store the last processed file name\n// Debounce utility function\nthis.debounce=(func,delay)=>{let timeoutId;return function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}if(timeoutId)clearTimeout(timeoutId);timeoutId=setTimeout(()=>{func(...args);},delay);};};// Debounced download function\nthis.debouncedDownload=this.debounce(link=>{link.click();document.body.removeChild(link);},300);this.render=()=>{// Retrieve the data from the props\nconst imageData=this.props.args[\"imageData\"];const fileName=this.props.args[\"fileName\"]||\"output.pdf\";const imageList=this.props.args[\"imageList\"];const dpi=this.props.args[\"dpi\"]||300;const pageSize=this.props.args[\"pageSize\"]||{width:8.5,height:11};const bleed=this.props.args[\"bleed\"]||false;// Handle single or batch processing\nif(!this.isProcessing){if(imageData){// Check if the input is the same as the last processed one\nif(imageData!==this.lastProcessedImageData||fileName!==this.lastProcessedFileName){this.isProcessing=true;this.lastProcessedImageData=imageData;// Update the last processed image data\nthis.lastProcessedFileName=fileName;// Update the last processed file name\nthis.convertSingleImageToPdf(imageData,fileName,dpi,pageSize,bleed);}}else if(imageList&&imageList.length>0){this.isProcessing=true;this.convertImagesToSinglePdf(imageList,dpi,pageSize,bleed);}}// Return an empty div or nothing if no message needs to be displayed\nreturn/*#__PURE__*/_jsx(\"div\",{});};this.convertSingleImageToPdf=async(imageData,fileName,dpi,pageSize,bleed)=>{try{const pdfDoc=await PDFDocument.create();await this.addImageToPdf(pdfDoc,imageData,dpi,pageSize,bleed);const pdfBytes=await pdfDoc.save();const blob=new Blob([pdfBytes],{type:\"application/pdf\"});const url=URL.createObjectURL(blob);const link=document.createElement(\"a\");link.href=url;link.download=fileName;document.body.appendChild(link);this.debouncedDownload(link);// Use the debounced download function\nStreamlit.setComponentValue(true);// Indicate success\n}catch(error){console.error(\"Error generating PDF:\",error);Streamlit.setComponentValue(false);// Indicate failure\n}finally{this.isProcessing=false;// Reset processing flag\n}};this.convertImagesToSinglePdf=async(imageList,dpi,pageSize,bleed)=>{try{const pdfDoc=await PDFDocument.create();for(const{imageData}of imageList){await this.addImageToPdf(pdfDoc,imageData,dpi,pageSize,bleed);}const pdfBytes=await pdfDoc.save();const blob=new Blob([pdfBytes],{type:\"application/pdf\"});const url=URL.createObjectURL(blob);const link=document.createElement(\"a\");link.href=url;link.download=\"bulk_images.pdf\";document.body.appendChild(link);this.debouncedDownload(link);// Use the debounced download function\nStreamlit.setComponentValue(true);// Indicate success\n}catch(error){console.error(\"Error generating single PDF:\",error);Streamlit.setComponentValue(false);// Indicate failure\n}finally{this.isProcessing=false;// Reset processing flag\n}};this.addImageToPdf=async(pdfDoc,imageData,dpi,pageSize,bleed)=>{const imageBytes=Uint8Array.from(atob(imageData),c=>c.charCodeAt(0));const embeddedImage=await pdfDoc.embedPng(imageBytes);const pageWidthInPoints=pageSize.width*72;const pageHeightInPoints=pageSize.height*72;let scale,scaledWidth,scaledHeight,xOffset,yOffset;if(bleed){// Scale to cover the entire page, overlapping as necessary\nconst widthRatio=pageWidthInPoints/embeddedImage.width;const heightRatio=pageHeightInPoints/embeddedImage.height;scale=Math.max(widthRatio,heightRatio);scaledWidth=embeddedImage.width*scale;scaledHeight=embeddedImage.height*scale;xOffset=(pageWidthInPoints-scaledWidth)/2;yOffset=(pageHeightInPoints-scaledHeight)/2;}else{// Scale to fit within margins\nconst margin=0.75*72;// 0.75-inch margin\nconst contentWidth=pageWidthInPoints-2*margin;const contentHeight=pageHeightInPoints-2*margin;const widthRatio=contentWidth/embeddedImage.width;const heightRatio=contentHeight/embeddedImage.height;scale=Math.min(widthRatio,heightRatio);scaledWidth=embeddedImage.width*scale;scaledHeight=embeddedImage.height*scale;xOffset=(contentWidth-scaledWidth)/2+margin;yOffset=(contentHeight-scaledHeight)/2+margin;}const page=pdfDoc.addPage([pageWidthInPoints,pageHeightInPoints]);page.drawImage(embeddedImage,{x:xOffset,y:yOffset,width:scaledWidth,height:scaledHeight});};}}// Export the component\nexport default withStreamlitConnection(PDFComponent);","map":{"version":3,"names":["Streamlit","StreamlitComponentBase","withStreamlitConnection","React","PDFDocument","jsx","_jsx","PDFComponent","constructor","arguments","isProcessing","lastProcessedImageData","lastProcessedFileName","debounce","func","delay","timeoutId","_len","length","args","Array","_key","clearTimeout","setTimeout","debouncedDownload","link","click","document","body","removeChild","render","imageData","props","fileName","imageList","dpi","pageSize","width","height","bleed","convertSingleImageToPdf","convertImagesToSinglePdf","pdfDoc","create","addImageToPdf","pdfBytes","save","blob","Blob","type","url","URL","createObjectURL","createElement","href","download","appendChild","setComponentValue","error","console","imageBytes","Uint8Array","from","atob","c","charCodeAt","embeddedImage","embedPng","pageWidthInPoints","pageHeightInPoints","scale","scaledWidth","scaledHeight","xOffset","yOffset","widthRatio","heightRatio","Math","max","margin","contentWidth","contentHeight","min","page","addPage","drawImage","x","y"],"sources":["C:/Users/lukeb/Downloads/my_component/pdf_component/frontend/src/MyComponent.tsx"],"sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\";\nimport React, { ReactNode } from \"react\";\nimport { PDFDocument } from \"pdf-lib\";\n\nclass PDFComponent extends StreamlitComponentBase {\n  private isProcessing: boolean = false; // Guard to prevent double execution\n  private lastProcessedImageData: string | null = null; // Store the last processed image data\n  private lastProcessedFileName: string | null = null; // Store the last processed file name\n\n  // Debounce utility function\n  private debounce = (func: Function, delay: number) => {\n    let timeoutId: NodeJS.Timeout;\n    return (...args: any[]) => {\n      if (timeoutId) clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        func(...args);\n      }, delay);\n    };\n  };\n\n  // Debounced download function\n  private debouncedDownload = this.debounce((link: HTMLAnchorElement) => {\n    link.click();\n    document.body.removeChild(link);\n  }, 300);\n\n  public render = (): ReactNode => {\n    // Retrieve the data from the props\n    const imageData = this.props.args[\"imageData\"] as string;\n    const fileName = this.props.args[\"fileName\"] || \"output.pdf\";\n    const imageList = this.props.args[\"imageList\"] as Array<{ imageData: string; fileName: string }>;\n    const dpi = this.props.args[\"dpi\"] || 300;\n    const pageSize = this.props.args[\"pageSize\"] || { width: 8.5, height: 11 };\n    const bleed = this.props.args[\"bleed\"] || false;\n\n    // Handle single or batch processing\n    if (!this.isProcessing) {\n      if (imageData) {\n        // Check if the input is the same as the last processed one\n        if (imageData !== this.lastProcessedImageData || fileName !== this.lastProcessedFileName) {\n          this.isProcessing = true;\n          this.lastProcessedImageData = imageData; // Update the last processed image data\n          this.lastProcessedFileName = fileName; // Update the last processed file name\n          this.convertSingleImageToPdf(imageData, fileName, dpi, pageSize, bleed);\n        }\n      } else if (imageList && imageList.length > 0) {\n        this.isProcessing = true;\n        this.convertImagesToSinglePdf(imageList, dpi, pageSize, bleed);\n      }\n    }\n\n    // Return an empty div or nothing if no message needs to be displayed\n    return <div></div>;\n  };\n\n  private convertSingleImageToPdf = async (\n    imageData: string,\n    fileName: string,\n    dpi: number,\n    pageSize: { width: number; height: number },\n    bleed: boolean\n  ): Promise<void> => {\n    try {\n      const pdfDoc = await PDFDocument.create();\n      await this.addImageToPdf(pdfDoc, imageData, dpi, pageSize, bleed);\n\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([pdfBytes], { type: \"application/pdf\" });\n      const url = URL.createObjectURL(blob);\n\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = fileName;\n      document.body.appendChild(link);\n\n      this.debouncedDownload(link); // Use the debounced download function\n      Streamlit.setComponentValue(true); // Indicate success\n    } catch (error) {\n      console.error(\"Error generating PDF:\", error);\n      Streamlit.setComponentValue(false); // Indicate failure\n    } finally {\n      this.isProcessing = false; // Reset processing flag\n    }\n  };\n\n  private convertImagesToSinglePdf = async (\n    imageList: Array<{ imageData: string; fileName: string }>,\n    dpi: number,\n    pageSize: { width: number; height: number },\n    bleed: boolean\n  ): Promise<void> => {\n    try {\n      const pdfDoc = await PDFDocument.create();\n\n      for (const { imageData } of imageList) {\n        await this.addImageToPdf(pdfDoc, imageData, dpi, pageSize, bleed);\n      }\n\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([pdfBytes], { type: \"application/pdf\" });\n      const url = URL.createObjectURL(blob);\n\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = \"bulk_images.pdf\";\n      document.body.appendChild(link);\n\n      this.debouncedDownload(link); // Use the debounced download function\n      Streamlit.setComponentValue(true); // Indicate success\n    } catch (error) {\n      console.error(\"Error generating single PDF:\", error);\n      Streamlit.setComponentValue(false); // Indicate failure\n    } finally {\n      this.isProcessing = false; // Reset processing flag\n    }\n  };\n\n  private addImageToPdf = async (\n    pdfDoc: PDFDocument,\n    imageData: string,\n    dpi: number,\n    pageSize: { width: number; height: number },\n    bleed: boolean\n  ): Promise<void> => {\n    const imageBytes = Uint8Array.from(atob(imageData), (c) => c.charCodeAt(0));\n    const embeddedImage = await pdfDoc.embedPng(imageBytes);\n\n    const pageWidthInPoints = pageSize.width * 72;\n    const pageHeightInPoints = pageSize.height * 72;\n\n    let scale, scaledWidth, scaledHeight, xOffset, yOffset;\n\n    if (bleed) {\n      // Scale to cover the entire page, overlapping as necessary\n      const widthRatio = pageWidthInPoints / embeddedImage.width;\n      const heightRatio = pageHeightInPoints / embeddedImage.height;\n      scale = Math.max(widthRatio, heightRatio);\n      scaledWidth = embeddedImage.width * scale;\n      scaledHeight = embeddedImage.height * scale;\n      xOffset = (pageWidthInPoints - scaledWidth) / 2;\n      yOffset = (pageHeightInPoints - scaledHeight) / 2;\n    } else {\n      // Scale to fit within margins\n      const margin = 0.75 * 72; // 0.75-inch margin\n      const contentWidth = pageWidthInPoints - 2 * margin;\n      const contentHeight = pageHeightInPoints - 2 * margin;\n\n      const widthRatio = contentWidth / embeddedImage.width;\n      const heightRatio = contentHeight / embeddedImage.height;\n      scale = Math.min(widthRatio, heightRatio);\n      scaledWidth = embeddedImage.width * scale;\n      scaledHeight = embeddedImage.height * scale;\n      xOffset = (contentWidth - scaledWidth) / 2 + margin;\n      yOffset = (contentHeight - scaledHeight) / 2 + margin;\n    }\n\n    const page = pdfDoc.addPage([pageWidthInPoints, pageHeightInPoints]);\n    page.drawImage(embeddedImage, {\n      x: xOffset,\n      y: yOffset,\n      width: scaledWidth,\n      height: scaledHeight,\n    });\n  };\n}\n\n// Export the component\nexport default withStreamlitConnection(PDFComponent);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}